#version 460 core
#extension GL_EXT_ray_tracing : require


layout(binding = 8) uniform u_obj_obj {
    vec3 camera_pos;
    ivec2 screen_size;
    int primitives_count;
    int data_count;
    int normals_count;
    int composed_object_nodes_count;
    uint ray_intersections_info_bits_size;
    int batches_count;
} ubo;
struct Quat
{
//a.x - a0, a - a.yzw
//к сожалению придется так из за padding
    vec4 a;
};
struct Primitive
{
    uint type;
    uint data_index;
    //сколько элементов в data_array она занимает. Кроме многогранника, для которого это количество вершин
    uint data_count;
    //для многогранника сначала пойдут точки а потом сразу нормали
    uint normals_index;
    vec3 position;
    //rdivh для конуса
    float sc3;
    Quat rotation;
    //для многогранника это количество граней
    uint normals_count;
    //половина высоты для призмы и цилиндра, высота для пирамиды и конуса, радиус для сферы, 
    float sc1;
    //радиус для цилиндра и конуса
    float sc2;
    //для многогранника. Остальная информация для него будет идти в int_data. [0] это индекс в матричный массив, затем таблица, задающая грани:на каждую строчку идет [количество элементов в массиве] и сам массив.
    //для многоугольников в собственных координатах это идет просто подряд без указания размера, поэтому итерироваться они обязаны одновременно с гранями.
    uint int_data_index;
    //пока что цвет потом может заменится на текстурную координату или типо того
    vec4 color;
    mat4 transformation;
    mat3 rotation_mat;
    mat3 back_rotation;
};

const int OBJECTS_ADD = -1;
const int OBJECTS_MULT = -2;
const int OBJECTS_SUB = -3;
const int OBJECTS_HIERARCHY = -4;

struct ComposedObjectNode
{
//положительный означает примитив. Отрицательный - операцию. 
    int operation;
//положительное число - указатель на bb_data. -1 - отсутствие боундинг бокса
    int bb_index;
};

layout(binding = 6) buffer composed_objects_array
{
    ComposedObjectNode composed_objects[];
};

#define ComposedObjectNode_isPrimitive(X) (X.operation >= 0)
#define ComposedObjectNode_getPrimitiveIndex(X) (X.operation)

#define ComposedObjectNode_left(R, N) ((2*((N) - (R) + 1) - 1) + (R))
#define ComposedObjectNode_right(R, N) ((2*((N) - (R) + 1)) + (R))
#define ComposedObjectNode_parent(R, N) ((((N) - (R) + 1)/2 - 1) + (R))




layout(binding = 1) buffer primitives_array
{
    Primitive primitives[];
};
layout(binding = 2, std430) buffer data_array
{
    vec2 base_points[];
};
layout(binding = 3, std430) buffer normals_array
{
    vec3 normals[];
};
layout(binding = 4) buffer int_array
{
    int int_data[];
};
layout(binding = 5) buffer matrix_array
{
    mat3 matrix_data[];
};
struct BoundingBoxData
{
    vec3 hsize;
    float dump1;
    vec3 position;
    float dump2;
};
layout(binding = 7) buffer bounding_boxes_array
{
    BoundingBoxData bb_data[];
};
//Положительный или 0 - это примитив, ссылка на место в primitives[]. Отрицательный - ссылка на корень в composed_objects[].
//Нулевой в нем заполняется мусором, (иначе 0 не ясно куда).
layout(binding = 10) buffer blas_objects_buffer
{
    int blas_objects[];
};


//Возможно стоит сделать эти вещи дефайнами
uint Polyhedron_vertexAmount(Primitive obj)
{
    return obj.data_count;
}

uint Polyhedron_edgesAmount(Primitive obj)
{
    return obj.normals_count;
}

uint Polyhedron_pointsStart(Primitive obj)
{
    return obj.normals_index;
}
uint Polyhedron_polygons2dStart(Primitive obj)
{
    return obj.data_index;
}
uint Polyhedron_matrixesStart(Primitive obj)
{
    return int_data[obj.int_data_index];
}
uint Polyhedron_edges2dStart(Primitive obj)
{
    return obj.int_data_index + 1;
}
uint Polyhedron_normalsStart(Primitive obj)
{
    return obj.data_index + Polyhedron_vertexAmount(obj);
}

struct Intersection
{
    vec3 n;
    float t;
};

struct IRO
{
    int inters;
    Intersection first, second;
};
struct FullIntersectionResult
{
    Intersection inter;
    vec4 color;
    //индекс примитива в дереве composed_objects с которым произошло первое пересечение. Для получения его индекса как примитива следует вызвать ComposedObjectNode_getPrimitiveIndex(composed_objects[object_index])
    int object_index;
};



const uint BOX = 0;
const uint PRIZM = 1;
const uint CONE = 2;
const uint PIRAMID = 3;
const uint CYLINDR = 4;
const uint SPHERE = 5;
const uint POLYHEDRON = 6;
const uint COMPOSED_OBJECT = 7;

//некоторая инкапсуляция для примитивов. sc1, sc2 - это еще ладно но обращение к буферам точно надо
uint Prizm_polygonStart(Primitive obj)
{
    return obj.data_index;
}

uint Prizm_polygonSize(Primitive obj)
{
    return obj.data_count;
}

uint Prizm_normalsStart(Primitive obj)
{
    return obj.normals_index;
}

uint Prizm_normalsSize(Primitive obj)
{
    return obj.normals_count;
}

uint Piramid_polygonStart(Primitive obj)
{
    return obj.data_index;
}

uint Piramid_polygonSize(Primitive obj)
{
    return obj.data_count;
}

uint Piramid_normalsStart(Primitive obj)
{
    return obj.normals_index;
}

uint Piramid_normalsSize(Primitive obj)
{
    return obj.normals_count;
}

Quat mult(in Quat a, in Quat b)
{
    return Quat(vec4(a.a.x * b.a.x - dot(a.a.yzw, b.a.yzw), a.a.x * b.a.yzw + b.a.x * a.a.yzw + cross(a.a.yzw, b.a.yzw)));
}

Quat inverseRot(in Quat q)
{
    return Quat(vec4(q.a.x, -1 * q.a.yzw));
}

mat4 rotation(in Quat q)
{
    float a0 = q.a.x;
    float a1 = q.a.y;
    float a2 = q.a.z;
    float a3 = q.a.w;

    return mat4(a1*a1 + a0*a0 - a2*a2 - a3*a3, 2*a2*a1 + 2*a0*a3, 2*a3*a1 - 2*a0*a2, 0, 2*a2*a1 - 2*a3*a0, a2*a2 + a0*a0 - a3*a3 - a1*a1, 2*a3*a2 + 2*a1*a0, 0, 2*a3*a1 + 2*a2*a0, 2*a3*a2 - 2*a1*a0, a3*a3 + a0*a0 - a2*a2 - a1*a1, 0, 0, 0, 0, 1);
}
mat3 rotation3(in Quat q)
{
    float a0 = q.a.x;
    float a1 = q.a.y;
    float a2 = q.a.z;
    float a3 = q.a.w;

    return mat3(a1*a1 + a0*a0 - a2*a2 - a3*a3, 2*a2*a1 + 2*a0*a3, 2*a3*a1 - 2*a0*a2, 2*a2*a1 - 2*a3*a0, a2*a2 + a0*a0 - a3*a3 - a1*a1, 2*a3*a2 + 2*a1*a0, 2*a3*a1 + 2*a2*a0, 2*a3*a2 - 2*a1*a0, a3*a3 + a0*a0 - a2*a2 - a1*a1);
}
void rotate(inout Quat q, float angle, vec3 n) {
    q = mult(q, Quat(vec4(cos(angle / 2), sin(angle / 2) * normalize(n))));
}



//количество доступных точек. точки которые вылазят за стек будут отброшены.
#define STACK_SIZE 30
//определяет размер стека при проходе csg дерева, в котором хранится указатель на список пересечений левого нода.
#define MAX_TREE_DEPTH 7
struct IntersectionListUnit
{
    Intersection data;
    int next_index;
    bool is_in;
    //возможно хорошая идея переместить этот инт в Intersection. Хотя мне не нравится паддинг тогда ну и там оно бесполезно пока
    //здесь индекс обьекта с чем пересекся луч в виде индекса в дереве composed_objects. Таким образом, индекс примитива, это composed_object[object_index].operation (или лучше ComposedObjectNode_getPrimitiveIndex(object_index) )
    int object_index;
};
IntersectionListUnit intersections_stack[STACK_SIZE];
//поскольку удаление не предусмотренно, мы просто идем вправо. То есть есть ограничение по в целом количеству пересечений на обьекте.
int stack_index = 0;


const IRO ZERO_IRO = IRO(0, Intersection( vec3(0,0,0), 0), Intersection( vec3(0,0,0),0));



int intersectSphereWithLine(in Primitive sphere, in int primitive_index, in vec3 start, in vec3 dir)
{

    float rad = sphere.sc1;
    float A = dot(dir, dir);
    float B_half = dot(start, dir);
    float C = dot(start, start) - rad * rad;

    float D_4 = B_half * B_half - A * C;
    if (D_4 < 0)
    {
        return -1;
    }
    float D_sq = sqrt(D_4);
    float t1 = (-B_half - D_sq) / A;
    float t2 = (-B_half + D_sq) / A;

    //IRO res = {2, { (start + dir * t1)*(1.0/rad),t1}, { (start + dir * t2)*(1.0/rad),t2}};
    intersections_stack[stack_index] = IntersectionListUnit(Intersection((start + dir * t1)*(1.0/rad), t1), stack_index + 1, true, primitive_index);
    intersections_stack[stack_index + 1] = IntersectionListUnit(Intersection((start + dir * t2)*(1.0/rad), t2), -1, false, primitive_index);
    stack_index += 2;
    return stack_index - 2;
}

bool equal(float a, float b)
{
    return abs(a - b) < 1e-5;
}
IRO intersectLineWithCircle(in vec2 p, in vec2 dir, float rad)
{
    float A = (dir.x * dir.x + dir.y * dir.y);
    float B_half = p.x * dir.x + p.y * dir.y;
    float C = p.x * p.x + p.y * p.y - rad * rad;
    float D = B_half * B_half - A * C;
    if (D < 0)
        return ZERO_IRO;
    float D_sq = sqrt(D);
    //не уверен что это нужно и полезно
    if (equal(D_sq, 0))
    {
        float t = -B_half / A;
        vec2 point = p + t * dir;
        IRO res = {1, {vec3(p.xy, 0),t }, { vec3(p.xy, 0),t}};
        return res;
    }
    float t1 = (-B_half - D_sq) / A;
    float t2 = (-B_half + D_sq) / A;
    vec2 p1 = (p + dir * t1) * (1.0/rad);
    vec2 p2 = (p + dir * t2) * (1.0/rad);
    IRO res = { 2, { vec3(p1,0),t1}, { vec3(p2, 0),t2} };
    return res;
}

void swap(inout Intersection a, inout Intersection b)
{
    Intersection c = a;
    a = b;
    b = c;
}

void swap(inout float a, inout float b)
{
    float c = a;
    a = b;
    b = c;
}

int intersectCylinderWithLine(in Primitive obj, in int primitive_index, in vec3 start, in vec3 dir)
{
    float rad = obj.sc2;
    float half_height = obj.sc1;
    if (equal(dir.x, 0.0) && equal(dir.y, 0.0))
    {
        bool in_res = dot(start.xy, start.xy) < rad * rad;
        if (in_res)
        {
            //IRO res = {2, { {0,0,1},(half_height - start.z) / dir.z}, {{0,0,-1},(-half_height - start.z) / dir.z}};
            intersections_stack[stack_index] = IntersectionListUnit(Intersection(vec3(0,0,1), (half_height - start.z) / dir.z),
             stack_index + 1, true, primitive_index);
            intersections_stack[stack_index + 1] = IntersectionListUnit(Intersection(vec3(0,0,1), (half_height - start.z) / dir.z),
             -1, false, primitive_index);
            stack_index += 2;
            return stack_index - 2;
        }
        return -1;
    }
    IRO shade_intersect = intersectLineWithCircle(start.xy, dir.xy, rad);

    if (shade_intersect.inters == 0)
    {
        return -1;
    }

    /*Intersection t1 = shade_intersect.first;
    float point_z = start.z + dir.z * t1.t;
    if (shade_intersect.inters == 1)
    {
        return -1;
        if (point_z >= -half_height && point_z <= half_height)
        {
            //return shade_intersect;
        }
        //return ZERO_IRO;
    }
    Intersection t2 = shade_intersect.second;
    float point_z2 = start.z + dir.z * t2.t;
    if (!(point_z >= -half_height && point_z <= half_height) && (point_z2 >= -half_height && point_z2 <= half_height))
    {
        swap(t1, t2);
        swap(point_z, point_z2);
        swap(shade_intersect.first, shade_intersect.second);
    }
    if (point_z >= -half_height && point_z <= half_height)
    {
        if (point_z2 >= -half_height && point_z2 <= half_height)
        {
            intersections_stack[stack_index] = IntersectionListUnit(shade_intersect.first, stack_index + 1, true, primitive_index);
            intersections_stack[stack_index + 1] = IntersectionListUnit(shade_intersect.second, -1, false, primitive_index);
            stack_index += 2;
            return stack_index - 2;
            return shade_intersect;
        }
        //z != 0 т к произошел подьем

        if (point_z2 > half_height)
        {
            float t_out = (half_height - start.z) / dir.z;
            IRO res = {2, t1, { {0,0,1},t_out}};
            return res;
        }
        if (point_z2 < -half_height)
        {
            float t_out = (-half_height - start.z) / dir.z;
            IRO res = {2, t1, { {0, 0, -1},t_out}};
            return res;

        }
    }*/
    float point_z = start.z + dir.z * shade_intersect.first.t;
    float point_z2 = start.z + dir.z * shade_intersect.second.t;
    bool fir_b = false, sec_b = false;
    if (point_z < -half_height && point_z2 < -half_height || point_z > half_height && point_z2 > half_height)
        return -1;
    if (point_z >= -half_height && point_z <= half_height)
    {
        intersections_stack[stack_index] = IntersectionListUnit(shade_intersect.first, stack_index + 1, true, primitive_index);
        fir_b = true;
    }
    if (point_z2 >= -half_height && point_z2 <= half_height)
    {
        intersections_stack[stack_index + 1] = IntersectionListUnit(shade_intersect.second, -1, false, primitive_index);
        sec_b = true;
    }
    if (fir_b && sec_b)
    {
        stack_index += 2;
        return stack_index - 2;
    }
    if (equal(dir.z, 0))
    {
        //если линия горизонтальна и пересекает цилиндр, то мы бы уже вышли с p_c == 2
        return -1;
    }
    float t_top, t_bot;
    if (!fir_b)
    {
        if (dir.z > 0)
        {
            t_bot = (-half_height - start.z) / dir.z;
            intersections_stack[stack_index] = IntersectionListUnit(Intersection(vec3(0,0,-1), t_bot), stack_index + 1, true, primitive_index);
        }
        else
        {
            t_top = (half_height - start.z) / dir.z;
            intersections_stack[stack_index] = IntersectionListUnit(Intersection(vec3(0,0,1), t_top), stack_index + 1, true, primitive_index);
        }
    }
    if (!sec_b)
    {
        if (dir.z > 0)
        {
            if (fir_b)
                t_top = (half_height - start.z) / dir.z;
            intersections_stack[stack_index + 1] = IntersectionListUnit(Intersection(vec3(0,0,1), t_top), -1, false, primitive_index);
        }
        else
        {
            if (fir_b)
                t_bot = (-half_height - start.z) / dir.z;
            intersections_stack[stack_index + 1] = IntersectionListUnit(Intersection(vec3(0,0,-1), t_bot), -1, false, primitive_index);
        }
    }
    
    stack_index += 2;
    return stack_index - 2;
}

#define POINT_ON_BOUNDARY 0
#define POINT_IN_POLYGON 1
#define POINT_OUT_OF_POLYGON 2

//специфичное сравнение для проверки на принадлежность многоугольнику
int compareDouble(float a, float b, float eps)
{
    if (abs(a - b) < eps)
        return 0;
    else if (a < b)
        return -1;
    else
        return 1;
}
int signDouble(float a, float eps)
{
    if (abs(a) < eps)
        return 0;
    if (a < 0)
        return -1;
    return 1;
}

int sideOfPointRelativeToLine(vec2 point, vec2 low, vec2 high)
{
    //considering low.y < high.y
    vec2 v1 = high - low;
    vec2 v2 = point - low;
    float z_orient = v1.x * v2.y - v1.y * v2.x;

    return compareDouble(0, z_orient, 1e-4);
}
float cross2(vec2 a, vec2 b)
{
    return a.x * b.y - b.x * a.y;
}

uint isPointInsidePolygon(vec2 p, uint pol_start, uint pol_size)
{

    int current = 0;
    if (pol_size < 2)
        return POINT_OUT_OF_POLYGON;

    bool IsInside = false;
    int cur_y_comp_res = compareDouble(base_points[pol_start + current].y, p.y, 1e-4);
    int next = 1;
    do 
    {
        
        int next_y_comp_res = compareDouble(base_points[pol_start + next].y, p.y, 1e-4);
        switch (cur_y_comp_res) {
        case -1:
            switch (next_y_comp_res) {
            case -1:
                break;
            case 0:
                switch (compareDouble(p.x, base_points[pol_start + next].x, 1e-4)) {
                case -1: IsInside = !IsInside; break;
                case 0:   return POINT_ON_BOUNDARY;
                case 1:  break;
                }
                break;
            case 1:
                switch (sideOfPointRelativeToLine(p, base_points[pol_start + current], base_points[pol_start + next])) {
                case -1: IsInside = !IsInside; break;
                case  0: return POINT_ON_BOUNDARY;
                }
                break;
            }
            break;
        case 0:
            switch (next_y_comp_res) {
            case -1:
                switch (compareDouble(p.x, base_points[pol_start + current].x, 1e-4)) {
                case -1: IsInside = !IsInside; break;
                case 0:   return POINT_ON_BOUNDARY;
                case 1:  break;
                }
                break;
            case 0:
                switch (compareDouble(p.x, base_points[pol_start + current].x, 1e-4)) {
                case -1:
                    if (compareDouble(p.x, base_points[pol_start + next].x, 1e-4) != -1)
                        return POINT_ON_BOUNDARY;
                    break;
                case 0: return POINT_ON_BOUNDARY;
                case 1:
                    if (compareDouble(p.x, base_points[pol_start + next].x, 1e-4) != 1)
                        return POINT_ON_BOUNDARY;
                    break;
                }
                break;
            case 1:
                if (compareDouble(p.x, base_points[pol_start + current].x, 1e-4) == 0) {
                    return POINT_ON_BOUNDARY;
                }
                break;
            }
            break;
        case 1:
            switch (next_y_comp_res) {
            case -1:
                switch (sideOfPointRelativeToLine(p, base_points[pol_start + next], base_points[pol_start + current])) {
                case -1: IsInside = !IsInside; break;
                case  0: return POINT_ON_BOUNDARY;
                }
                break;
            case 0:
                if (compareDouble(p.x, base_points[pol_start + next].x, 1e-4) == 0) {
                    return POINT_ON_BOUNDARY;
                }
                break;
            case 1:
                break;
            }
            break;
        }

        current = next;
        cur_y_comp_res = next_y_comp_res;
        ++next;
        if (next == pol_size)
            next = 0;
    } while (current != 0);

    return IsInside ? POINT_IN_POLYGON : POINT_OUT_OF_POLYGON;
    /*int cross_dir = signDouble(cross2(base_points[pol_start + pol_size - 1] - p, base_points[pol_start] - p), 1e-4);
    if (cross_dir == 0)
        return POINT_ON_BOUNDARY;
    for (int i = 0; i < pol_size - 1; ++i)
    {
        int cr_dir = signDouble(cross2(base_points[pol_start + i] - p, base_points[pol_start + i + 1] - p), 1e-4);
        if (cr_dir == 0)
            return POINT_ON_BOUNDARY;
        if (cr_dir != cross_dir)
            return POINT_OUT_OF_POLYGON;
    }
    return POINT_IN_POLYGON;*/
}



float getParam(vec2 st, vec2 dir, vec2 p)
{
    if (equal(dir.x, 0))
    {
        return (p.y - st.y) / dir.y;
    }
    return (p.x - st.x) / dir.x;
}

struct BF_pair
{
    bool b;
    float f;
};

BF_pair rayIntersectsSegment(vec2 p, vec2 dir, vec2 a, vec2 b)
{
    float div = dir.x * (b.y - a.y) - dir.y * (b.x - a.x);
    float num = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);
    
    if (equal(div, 0))
    {
        if (equal(num, 0))
        {
            if (dot(b - p, a - p) < 0)
            {
                BF_pair res =  { true, 0 };
                return res;
            }
            else if (dot(dir, a - p) < 0)
            {
                BF_pair res =  { false, 0 };
                return res;
            }
            else if (dot(a - p, a - p) < dot(b - p, b - p))
            {
                BF_pair res =  { true, getParam(p, dir, a) };
                return res;
            }
            else
            {
                BF_pair res =  { true,getParam(p, dir, b) };
                return res;
            }

        }
        else
            {
                BF_pair res =  { false, 0 };
                return res;
            }
    }
    else
    {
        float t = num / div;
        //t /= 10;
        vec2 point = p + dir * t;
        //это место все еще может давать артефакты, в зависимости от числа в сравнении. 1e-6 работает вроде хорошо. Возможно стоит сделать проверку если point в окрестности a или b но это будет занимать время
        if (dot(b - point, a - point) <= 1e-6)
        {
            BF_pair res = {true, t};
            return res;
        }
        BF_pair res =  { false, 0 };
        return res;
    }

}


//IRO WHITE_IRO = {2, { {1, 1, 1},1}, { {0,-1,0},2}};
//IRO RED_IRO = {2, { {1,0,0},1}, { {0,0,0},2}};
//IRO GREEN_IRO = {2, { {0,1,0},1}, { {0,0,0},2}};
//IRO BLUE_IRO = {2, { {0,0,1},1}, { {0,0,0},2}};
//IRO YELLOW_IRO = {2, { {1,1,0},1}, { {0,0,0},2}};
//IRO MAGENTA_IRO = {2, { {1,0,1},1}, { {0,0,0},2}};
//IRO LIGHT_IRO = {2, { {0,1,1},1}, { {0,0,0},2}};
IRO _debugIRO(vec3 n)
{
    IRO Deb_r = {2, { n,1}, { {0,0,0},2}};
    return Deb_r;
}

//Intersection WHITE_INTER = { {1, 1, 1},1};
//Intersection RED_INTER =  { {1,0,0},1};
//Intersection GREEN_INTER =  { {0,1,0},1};
//Intersection BLUE_INTER =  { {0,0,1},1};
//Intersection YELLOW_INTER =  {{1,1,0},1};
//Intersection MAGENTA_INTER = {{1,0,1},1};
//Intersection LIGHT_INTER = {{0,1,1},1};
Intersection _debugINTER(vec3 n)
{
    Intersection Deb_r = { n,1};
    return Deb_r;
}

IRO rayIntersectsPolygon(vec2 p, in vec2 n, uint polygon_start, uint polygon_size, uint normals_start, uint normals_size)
{
    int c = 0;
    Intersection res[2];
    
    for (int i = 0; i < polygon_size; ++i)
    {
        BF_pair int_res = rayIntersectsSegment(p, n, base_points[polygon_start + i],base_points[polygon_start + (i < polygon_size - 1 ? i + 1 : 0)]);
        
        if (!int_res.b)
            continue;
        vec2 point = p + n * int_res.f;

        if (c == 1 && equal(int_res.f, res[0].t))
            continue;
        res[c].t = int_res.f;
        res[c].n = normals[normals_start + i];
        c++;
        if (c == 2)
            break;
    }

    //if (res[0].t < res[1].t)
    //  res[0].in = true;
    //else
    //  res[1].in = true;
    IRO irores = { c, res[0], res[1] };
    return irores;

}

float indic(float x)
{
    if (x < 0)
        return 0;
    return 1;
}
#define MAX_POINTS_FOR_PRIZM 6
int intersectPrizmWithLine(in Primitive obj, in int primitive_index, in vec3 start, in vec3 dir)
{
    float EPSILON = 1e-6;
    float half_height = obj.sc1;

    if (equal(dir.x, 0) && equal(dir.y, 0))
    {
        uint in_res = isPointInsidePolygon(start.xy, Prizm_polygonStart(obj), Prizm_polygonSize(obj));
        if (in_res != POINT_OUT_OF_POLYGON)
        {
            float t_up = (half_height - start.z) / dir.z;
            float t_down = (-half_height - start.z) / dir.z;
            if (t_up < t_down)
            {
                //IRO res = {2,  { {0,0,1},t_up}, { {0,0,-1},t_down }};
                intersections_stack[stack_index] = IntersectionListUnit(Intersection(vec3(0,0,1), t_up), stack_index + 1, true, primitive_index);
                intersections_stack[stack_index + 1] = IntersectionListUnit(Intersection(vec3(0,0,-1), t_down), -1, false, primitive_index);
                stack_index += 2;
                return stack_index - 2;
            }
            else
            {
                intersections_stack[stack_index] = IntersectionListUnit(Intersection(vec3(0,0,-1), t_down), stack_index + 1, true, primitive_index);
                intersections_stack[stack_index + 1] = IntersectionListUnit(Intersection(vec3(0,0,1), t_up), -1, false, primitive_index);
                stack_index += 2;
                return stack_index - 2;
            }
        }
        return -1;
    }

    int MAX_ALLOWED_POINTS = min(MAX_POINTS_FOR_PRIZM, STACK_SIZE - stack_index);

    int found_points = 0;
    //float min_t = 1e50;
    //int ind_of_min_t = -1;
    if (!equal(dir.z, 0))
    {
        float t_up = (half_height - start.z) / dir.z;
        uint in_res = isPointInsidePolygon(start.xy + dir.xy * t_up, Prizm_polygonStart(obj), Prizm_polygonSize(obj));
        if (in_res != POINT_OUT_OF_POLYGON)
        {
            intersections_stack[stack_index + found_points] = IntersectionListUnit(Intersection(vec3(0,0,1), t_up),-1, false, primitive_index);
            found_points++;
            //min_t = t_up;
            //ind_of_min_t = 0;
        }
        float t_down = (-half_height - start.z) / dir.z;
        in_res = isPointInsidePolygon(start.xy + dir.xy * t_down, Prizm_polygonStart(obj), Prizm_polygonSize(obj));
        if (in_res != POINT_OUT_OF_POLYGON)
        {
            intersections_stack[stack_index + found_points] = IntersectionListUnit(Intersection(vec3(0,0,-1), t_down),-1, false, primitive_index);
            found_points++;
            //if (min_t > t_down)
            //{
            //  min_t = t_down;
            //  ind_of_min_t++; //есди t_up зашла, то индофминт = 0, а должно стать 1. Иначе оно -1, а должно стать 0.
            //}
        }
    }

    uint polygon_size = Prizm_polygonSize(obj);
    uint polygon_start = Prizm_polygonStart(obj);
    uint normals_start = Prizm_normalsStart(obj);
    for (int i = 0; i < polygon_size; ++i)
    {
        BF_pair int_res = rayIntersectsSegment(start.xy, dir.xy, base_points[polygon_start + i],base_points[polygon_start + (i < polygon_size - 1 ? i + 1 : 0)]);
        
        if (!int_res.b)
            continue;
        vec3 point = start + dir * int_res.f;
        if (length(point.xy - base_points[polygon_start + i]) < 1e-4)
            continue;
        if (point.z < -half_height || point.z > half_height)
            continue;
        
        //if (int_res.f < min_t)
        //{
        //  min_t = int_res.f;
        //  ind_of_min_t = found_points;
        //}
        //мы все еще пытаемся найти первую точку, иначе совсем плохо с отображением будет
        if (found_points >= MAX_ALLOWED_POINTS)
            break;;
        intersections_stack[stack_index + found_points] = IntersectionListUnit(Intersection(normals[normals_start + i], int_res.f), -1, false, primitive_index);
        found_points++;

    }
    if (found_points < 2)
        return -1;
    /*//это надо сделать для удаления точек при иерархическом комбинировании
    if (ind_of_min_t > 0)
    {
        Intersection temp = intersections_stack[stack_index].data;
        intersections_stack[stack_index].data = intersections_stack[ind_of_min_t].data;
        intersections_stack[stack_index + ind_of_min_t].data = temp;
    }
    int */
    

    for (int i = 0; i < found_points; ++i)
    {
        for (int j = i + 1; j < found_points; ++j)
        {
            if (intersections_stack[stack_index + j].data.t < intersections_stack[stack_index + i].data.t)
            {
                Intersection temp = intersections_stack[stack_index + i].data;
                intersections_stack[stack_index + i].data = intersections_stack[stack_index + j].data;
                intersections_stack[stack_index + j].data = temp;
            }
        }
    }
    bool in_c = true;
    for (int i = 0; i < found_points; ++i)
    {
        intersections_stack[stack_index + i].is_in = in_c;
        in_c = !in_c;
        intersections_stack[stack_index + i].next_index = stack_index + i + 1;
    }
    intersections_stack[stack_index + found_points - 1].next_index = -1;
    stack_index += found_points;
    return stack_index - found_points;


    /*IRO shade_intersect = rayIntersectsPolygon(start.xy, dir.xy, Prizm_polygonStart(obj), Prizm_polygonSize(obj), Prizm_normalsStart(obj), Prizm_normalsSize(obj));

    if (shade_intersect.inters == 0)
    {
        return ZERO_IRO;
    }

    Intersection t1 = shade_intersect.first;
    float point_z = start.z + dir.z * t1.t;
    

    if (shade_intersect.inters == 1)
    {
        //если токо одно пересечение то пока не рисуем
        return ZERO_IRO;
        if (point_z >= -half_height - EPSILON && point_z <= half_height + EPSILON)
        {
            //если все же вернусь сюда то надо не забыть проставить нормально in и out
            IRO res = { 1, t1, t1 };
            return res;
        }
        return ZERO_IRO;
    }
    Intersection t2 = shade_intersect.second;
    float point_z2 = start.z + dir.z * t2.t;
    
    if (!(point_z >= -half_height - EPSILON && point_z <= half_height + EPSILON) && (point_z2 >= -half_height - EPSILON && point_z2 <= half_height + EPSILON))
    {
        swap(t1, t2);
        swap(point_z, point_z2);
        swap(shade_intersect.first, shade_intersect.second);
    }

    if (point_z >= -half_height - EPSILON && point_z <= half_height + EPSILON)
    {
        if (point_z2 >= -half_height - EPSILON && point_z2 <= half_height + EPSILON)
        {
            if (t1.t < t2.t)
            {
                IRO res = {2, t1, t2 };
                return res;
            }
            else
            {
                IRO res = {2, t2, t1};
                return res;
            }
        }
        
        //z != 0 т к произошел подьем
        if (point_z2 > half_height + EPSILON)
        {
            float t_out = (half_height - start.z) / dir.z;
            if (t1.t < t_out)
            {
                IRO res = {2,  t1, { {0, 0, 1},t_out } };
                return res;
            }
            else
            {
                IRO res = {2,  { {0, 0, 1},t_out }, t1 };
                return res;
            }
            //невозможная ситуация, т к если он не выходит в стене то должен выходить наверху но мало ли
            IRO res = {2, t1, t1 };
            return res;
        }
        if (point_z2 < -half_height - EPSILON)
        {
            
            float t_out = (-half_height - start.z) / dir.z;
            if (t1.t < t_out)
            {
                IRO res = {2, t1, { {0, 0, -1},t_out } };
                return res;
                
            }
            else
            {
                IRO res = {2, { {0, 0, -1},t_out }, t1 };
                return res;
            }
            IRO res = {2,  t1, t1 };
            
            return res;
            
        }
        
    }
    
    //осталось возможна только ситуация когда линия проходит через оба основания, через верхнее/нижнее ребро, либо вообще не проходит
    if (equal(dir.z, 0))
    {
        return ZERO_IRO;
    }
    if (point_z < -half_height && point_z2 < -half_height)
        return ZERO_IRO;
    if (point_z > half_height && point_z2 > half_height)
        return ZERO_IRO;
    float t_out = (half_height - start.z) / dir.z;
    vec2 up_point = start.xy + dir.xy * t_out;
    
    //if (isPointInsidePolygon(up_point, Prizm_polygonStart(obj), Prizm_polygonSize(obj)) != POINT_OUT_OF_POLYGON)
    {
        float t_bot = (-half_height - start.z) / dir.z;
        if (t_out < t_bot)
        {
            IRO res = {2, { {0,0,1},t_out},  { {0,0,-1},t_bot} };
            return res;
        }
        else
        {
            IRO res = {2, { {0,0,-1},t_bot},  { {0,0,1},t_out} };
            return res;
        }
    }

    return ZERO_IRO;*/
}


int intersectConeWithLine(in Primitive object, in int primitive_index, in vec3 start, in vec3 dir)
{
    float height = object.sc1;
    float rad = object.sc2;
    float rdivh = object.sc3;

    float M_s = rdivh * rdivh;
    float A = dir.x * dir.x + dir.y * dir.y - M_s * dir.z * dir.z;
    float B_half = dir.x * start.x + dir.y * start.y - M_s * dir.z * start.z;
    float C = start.x * start.x + start.y * start.y - M_s * start.z * start.z;
    float D_4 = B_half * B_half - A * C;
    if (D_4 < 0)
        return -1;
    float D_sq_2 = sqrt(D_4);
    float t1 = (-B_half - D_sq_2) / A;
    float t2 = (-B_half + D_sq_2) / A;

    float z1 = start.z + dir.z * t1;
    float z2 = start.z + dir.z * t2;

    bool z1_good = z1 >= -height && z1 <= 0;
    bool z2_good = z2 >= -height && z2 <= 0;
    if (z1_good && z2_good)
    {
        vec2 p1 = start.xy + dir.xy * t1;
        vec2 p2 = start.xy + dir.xy * t2;

        float zn1 = -dot(p1, p1) / z1;
        float zn2 = -dot(p2, p2) / z2;

        //IRO res = {2, { normalize(vec3(p1, zn1)),t1}, { normalize(vec3(p2, zn2)),t2}};
        intersections_stack[stack_index] = IntersectionListUnit(Intersection(normalize(vec3(p1, zn1)), t1), stack_index + 1, true, primitive_index);
        intersections_stack[stack_index + 1] = IntersectionListUnit(Intersection(normalize(vec3(p2, zn2)), t2), -1, false, primitive_index);
        stack_index += 2;
        return stack_index - 2;
    }
    if (!z1_good && !z2_good)
        return -1;
    if (z2_good)
    {
        swap(t1, t2);
        swap(z1, z2);
    }
    //если линия пересекает усеченный конус в одном месте и не выходит в другом, то она гарантированно пройдет через основание
    vec2 p1 = start.xy + dir.xy * t1;
    float zn1 = -dot(p1, p1) / z1;

    float t_base = (-height - start.z) / dir.z;
    if (t_base < t1)
    {
        //IRO res = {2, { {0,0,-1},t_base}, { normalize(vec3(p1, zn1)),t1}};
        intersections_stack[stack_index] = IntersectionListUnit(Intersection(vec3(0, 0, -1), t_base), stack_index + 1, true, primitive_index);
        intersections_stack[stack_index + 1] = IntersectionListUnit(Intersection(normalize(vec3(p1, zn1)), t1), -1, false, primitive_index);
        stack_index += 2;
        return stack_index - 2;
    }
    //IRO res = {2, { normalize(vec3(p1, zn1)),t1}, { {0,0,-1},t_base}};
    intersections_stack[stack_index] = IntersectionListUnit(Intersection(normalize(vec3(p1, zn1)), t1), stack_index + 1, true, primitive_index);
    intersections_stack[stack_index + 1] = IntersectionListUnit(Intersection(vec3(0, 0, -1), t_base), -1, false, primitive_index);
    stack_index += 2;
    return stack_index - 2;
}


BF_pair intersectLineWithTriangle(vec3 p, vec3 dir, vec3 A, vec3 B, vec3 C)
{
    vec3 a = C - A, b = B - A;
    vec3 n = cross(a, b);
    if (equal(dot(n, dir), 0))
    {
        BF_pair r = {false, 0};
        return r;
    }
    float t = (dot(A, n) - dot(p, n)) / dot(dir, n);
    vec3 projection = p + dir * t;

    float sa = sign(dot(cross(projection - A, B - A), n));
    BF_pair res = { equal(sa, sign(dot(cross(projection - B, C - B), n))) && equal(sa, sign(dot(cross(projection - C, A - C), n))) , t };
    return res;
}

//пока оставляем основание выпуклым, пирамида с невыпуклым основанием это странно
int intersectPiramidWithLine(in Primitive obj, in int primitive_index, in vec3 start, in vec3 dir)
{
    float height = obj.sc1;

    int count = 0;
    Intersection t[2];
    if (!equal(dir.z, 0))
    {
        float t_lev = (-height - start.z) / dir.z;
        vec2 base_inter = start.xy + dir.xy * t_lev;
        if (isPointInsidePolygon(base_inter, Piramid_polygonStart(obj), Piramid_polygonSize(obj)) != POINT_OUT_OF_POLYGON)
        {
            t[count].t = t_lev;
            t[count].n = vec3(0,0,-1);
            count++;
        }
    }
    uint base_start = Piramid_polygonStart(obj);
    uint base_size = Piramid_polygonSize(obj);
    uint normals_start = Piramid_normalsStart(obj);
    uint normals_size = Piramid_normalsSize(obj);
    for (int i = 0; i < base_size; ++i)
    {
        BF_pair inter = intersectLineWithTriangle(start, dir, vec3(base_points[base_start + i].xy, -height), vec3(base_points[base_start + (i < base_size - 1 ? i + 1 : 0)], -height), vec3( 0,0,0 ));
        if (inter.b)
        {
            t[count].t = inter.f;
            t[count].n = normals[normals_start + i];
            count++;
        }
        if (count == 2)
            break;
    }
    if (count < 2)
        return -1;
    if (t[0].t < t[1].t)
    {
        //IRO res = {count, t[0], t[1]};
        //return res;
        intersections_stack[stack_index] = IntersectionListUnit(t[0], stack_index + 1, true, primitive_index);
        intersections_stack[stack_index + 1] = IntersectionListUnit(t[1], -1, false, primitive_index);
        stack_index += 2;
        return stack_index - 2;
    }
    intersections_stack[stack_index] = IntersectionListUnit(t[1], stack_index + 1, true, primitive_index);
    intersections_stack[stack_index + 1] = IntersectionListUnit(t[0], -1, false, primitive_index);
    stack_index += 2;
    return stack_index - 2;

}


bool checkIfLineIntersectBox(in vec3 size, in vec3 start, in vec3 dir)
{
    vec3 inv_dir = 1.0 / dir;
    vec3 t0s = (-size - start) * inv_dir;
    vec3 t1s = (size - start) * inv_dir;

    vec3 tsin = min(t0s, t1s);
    vec3 tsout = max(t0s, t1s);
    
    float t_in = max(tsin.x, max(tsin.y, tsin.z));
    float t_out = min(tsout.x, min(tsout.y, tsout.z));
    return (t_in < t_out) && (t_out > 0);
}
//size - half size
int intersectBoxShapeWithLine(in vec3 size, in int primitive_index, in vec3 start, in vec3 dir)
{
    vec3 inv_dir = 1.0 / dir;
    vec3 t0s = (-size - start) * inv_dir;
    vec3 t1s = (size - start) * inv_dir;

    vec3 tsin = min(t0s, t1s);
    vec3 tsout = max(t0s, t1s);


    float t_in = max(tsin.x, max(tsin.y, tsin.z));
    float t_out = min(tsout.x, min(tsout.y, tsout.z));
    if (t_in >= t_out || t_out <= 0)
        return -1;

    Intersection in_int, out_int;
    vec3 in_point_diff = abs(abs(start + dir * t_in) - size);
    vec3 out_point_diff = abs(abs(start + dir * t_out) - size);

    if (in_point_diff.x < in_point_diff.y && in_point_diff.x < in_point_diff.z)
        in_int.n = vec3(-1, 0, 0) * sign(dir.x);
    else if (in_point_diff.y < in_point_diff.z)
        in_int.n = vec3(0, -1, 0) * sign(dir.y);
    else
        in_int.n = vec3(0, 0, -1) * sign(dir.z);

    if (out_point_diff.x < out_point_diff.y && out_point_diff.x < out_point_diff.z)
        out_int.n = vec3(1, 0, 0) * sign(dir.x);
    else if (out_point_diff.y < out_point_diff.z)
        out_int.n = vec3(0, 1, 0) * sign(dir.y);
    else
        out_int.n = vec3(0, 0, 1) * sign(dir.z);

    in_int.t = t_in;
    out_int.t = t_out;
    //IRO res = {2, in_int, out_int};
    //return res;
    intersections_stack[stack_index] = IntersectionListUnit(in_int, stack_index + 1, true, primitive_index);
    intersections_stack[stack_index + 1] = IntersectionListUnit(out_int, -1, false, primitive_index);
    stack_index += 2;
    return stack_index - 2;

}

int intersectBoxWithLine(in Primitive obj, in int primitive_index, in vec3 start, in vec3 dir)
{
    vec3 size = vec3(obj.sc1, obj.sc2, obj.sc3);
    return intersectBoxShapeWithLine(size, primitive_index, start, dir);
}


//тоже пока оставляем выпуклым
int intersectPolyhedronWithLine(in Primitive obj, in int primitive_index, in vec3 start, in vec3 dir)
{
    
    Intersection res[2];
    int c = 0;
    uint int_data_iterator_sub1 = Polyhedron_edges2dStart(obj);
    uint polygons_iterator = Polyhedron_polygons2dStart(obj);
    uint normals_start = Polyhedron_normalsStart(obj);
    uint points_start = Polyhedron_pointsStart(obj);

    
    for (int i = 0; i < Polyhedron_edgesAmount(obj); ++i)
    {
        float t = (dot(normals[points_start + int_data[int_data_iterator_sub1 + 1]], normals[normals_start + i]) - dot(start, normals[normals_start + i])) / dot(dir, normals[normals_start + i]);
        vec3 proj = start + dir * t;
        proj = proj - normals[points_start + int_data[int_data_iterator_sub1 + 1]];
        vec2 p_in_polygon = (matrix_data[Polyhedron_matrixesStart(obj) + i] * proj).xy;

        if (isPointInsidePolygon(p_in_polygon, polygons_iterator, int_data[int_data_iterator_sub1]) != POINT_OUT_OF_POLYGON)
        {
            if (c == 1 && equal(t, res[0].t))
                continue;
            //СЧИТАЕМ ВЫПУКЛЫМ
            /*else
            {
                //если границы входят в многоугольники то точка на ребрах может быть учитана несколько раз. Это немного сломает алгоритмы операций над множествами хотя модификацией это можно устранить. Но где будет больше потеря производительности здесь
                //или там если учитывать точки несколько раз.
                //если же границы исключать из многоугольников то будут черные линии с которыми особо ничего не сделаешь
                bool already_counted = false;
                for (auto& it : res)
                {
                    if (equal(it.t, t))
                    {
                        already_counted = true;
                        break;
                    }
                }
                if (already_counted)
                    continue;
            }*/
            Intersection to_res = { normals[normals_start + i],t};
            res[c] = to_res;
            ++c;
            if (c == 2)
                break;
            
        }
        polygons_iterator += int_data[int_data_iterator_sub1];
        int_data_iterator_sub1 += int_data[int_data_iterator_sub1] + 1;
    }
    if (c == 2)
    {
        if (res[0].t > res[1].t)
            swap(res[0], res[1]);
        //IRO irores = {2, res[0], res[1]};
        //return irores;
        intersections_stack[stack_index] = IntersectionListUnit(res[0], stack_index + 1, true, primitive_index);
        intersections_stack[stack_index + 1] = IntersectionListUnit(res[1], -1, false, primitive_index);
        stack_index += 2;
        return stack_index - 2;
    }
    
    return -1;
}


int intersectWithRay(in Primitive object, in int primitive_index, in vec3 ray_start, in vec3 direction)
{
    //Matrix<4> transposition(Vector<4>(1, 0, 0, -position.x()), Vector<4>(0, 1, 0, -position.y()), Vector<4>(0, 0, 1, -position.z()), Vector<4>(0, 0, 0, 1));
    //mat4 transposition = mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -object.position.x, -object.position.y, -object.position.z, 1);

    //mat4 rot = rotation(inverseRot(object.rotation));
    //mat4 transformation = rot * transposition;

    vec3 start = (object.transformation * vec4(ray_start, 1)).xyz;
    vec3 dir = object.rotation_mat * direction;

    int inter_res;

    switch(object.type)
    {
        case PRIZM:
            inter_res = intersectPrizmWithLine(object, primitive_index, start, dir);
            break;
        case PIRAMID:
            inter_res = intersectPiramidWithLine(object, primitive_index, start, dir);
            break;
        case CYLINDR:
            inter_res = intersectCylinderWithLine(object, primitive_index, start, dir);
            break;
        case SPHERE:
            inter_res = intersectSphereWithLine(object, primitive_index, start, dir);
            break;
        case CONE:
            inter_res = intersectConeWithLine(object, primitive_index, start, dir);
            break;
        case BOX:
            inter_res = intersectBoxWithLine(object, primitive_index, start, dir);
            break;
        case POLYHEDRON:
            inter_res = intersectPolyhedronWithLine(object, primitive_index, start, dir);
            break;
    }
    /*if (inter_res.inters == 0)
        return inter_res;
    if (inter_res.first.t < 0 && inter_res.second.t < 0)
    {
        IRO res = {0, {{0,0,0},0 }, { {0,0,0},0}};
        return res;
    }
    
    
    if (inter_res.second.t < inter_res.first.t && inter_res.second.t >= 0)
        swap(inter_res.first, inter_res.second);
    
    if (inter_res.second.t < 0)
    {
        inter_res.inters = 1;
    }
    
    //.first может быть < 0
    mat4 back_rotation = rotation(object.rotation);
    inter_res.first.n = (back_rotation * vec4(inter_res.first.n, 1)).xyz;
    inter_res.second.n = (back_rotation * vec4(inter_res.second.n, 1)).xyz;
    return inter_res;*/

    if (inter_res == -1)
        return -1;
    //mat3 back_rotation = rotation3(object.rotation);
    int cur_pointer = inter_res;
    while (cur_pointer != -1)
    {
        intersections_stack[cur_pointer].data.n = object.back_rotation * intersections_stack[cur_pointer].data.n;
        cur_pointer = intersections_stack[cur_pointer].next_index;
    }
    return inter_res;
}

float sq(float x)
{
    return x*x;
}





int intersectWithPrimitiveAsNode(int node, vec3 camera_pos, vec3 dir)
{
    if (stack_index > STACK_SIZE - 2)
        return -1;
    return intersectWithRay(primitives[ComposedObjectNode_getPrimitiveIndex(composed_objects[node])], node, camera_pos, dir);
    /*IRO inter_res = intersectWithRay(primitives[ComposedObjectNode_getPrimitiveIndex(composed_objects[node])], camera_pos, dir);
    switch(inter_res.inters)
    {
        case 0:
            return -1;
        case 1:
            //это просто касание, и не стоит это рассматривать. Потому что тогда is_in всеравно кривоватое.
            return -1;
        case 2:
            if (inter_res.first.t >= 0) //если .first >= 0 то и .second >= 0 точно
            {
                intersections_stack[stack_index] = IntersectionListUnit(inter_res.first, stack_index + 1, true, node);
                stack_index++;
                intersections_stack[stack_index++] = IntersectionListUnit(inter_res.second, -1, false, node);
                return stack_index - 2;
            }
            intersections_stack[stack_index++] = IntersectionListUnit(inter_res.second, -1, false, node); //вообще конечно вопрос как это повлияет на алгоритмы т-м операций но вроде бы должно быть нормально.
            return stack_index - 1;
    }*/
}

void pushBackToList(inout int list_start, inout int last_pushed, int to_push)
{
    if (last_pushed == -1)
        list_start = to_push;
    else
        intersections_stack[last_pushed].next_index = to_push;
    last_pushed = to_push;
}

//при этом листы, относящиеся к дочерним нодам разрушаются.
int uniteObjects(int left_it, int right_it)
{
    //int left_it = lists_stack[left];
    //int right_it = lists_stack[right];
    
    bool in_a = false;
    bool in_b = false;

    int last_pushed = -1;
    //это будет либо left_it, либо right_it. заполняется в pushBackToList
    int new_list_start = -1;
    while (left_it != -1 && right_it != -1)
    {
        if (intersections_stack[left_it].data.t < intersections_stack[right_it].data.t)
        {
        // точки не выбрасываем, потому что даже если обьект не прозрачный, то потом при вычитании из него дырки нужно все равно хранить внутренние обьекты
            //if (!in_b)
                pushBackToList(new_list_start, last_pushed, left_it);
            in_a = intersections_stack[left_it].is_in;
            left_it = intersections_stack[left_it].next_index;
        }
        else
        {
            //if (!in_a)
                pushBackToList(new_list_start, last_pushed, right_it);
            in_b = intersections_stack[right_it].is_in;
            right_it = intersections_stack[right_it].next_index;
        }
    }
    //сейчас одно из них дошло точно до конца поэтому никаких ифов можно не делать
    while (right_it != -1)
    {
        pushBackToList(new_list_start, last_pushed, right_it);
        right_it = intersections_stack[right_it].next_index;
    }
    while (left_it != -1)
    {
        pushBackToList(new_list_start, last_pushed, left_it);
        left_it = intersections_stack[left_it].next_index;
    }
    //это по сути закрытие листа, иначе финальный нод будет ссылаться на рандомный другой
    pushBackToList(new_list_start, last_pushed, -1);
    return new_list_start;
}

int intersectObjects(int left_it, int right_it)
{
    int in_a = 0;
    int in_b = 0;

    int last_pushed = -1;
    //int left_it = lists_stack[left];
    //int right_it = lists_stack[right];
    int new_list_start = -1;
    while (left_it != -1 && right_it != -1)
    {
        if (intersections_stack[left_it].data.t < intersections_stack[right_it].data.t)
        {
            if (in_b > 0)
                pushBackToList(new_list_start, last_pushed, left_it);
            in_a += 2*int(intersections_stack[left_it].is_in) - 1;
            left_it = intersections_stack[left_it].next_index;
        }
        else
        {
            if (in_a > 0)
                pushBackToList(new_list_start, last_pushed, right_it);
            in_b += 2*int(intersections_stack[right_it].is_in) - 1;
            right_it = intersections_stack[right_it].next_index;
        }
    }
    pushBackToList(new_list_start, last_pushed, -1);
    return new_list_start;
}

int subtractObjects(int left_it, int right_it)
{
    int in_a = 0;
    int in_b = 0;

    //int left_it = lists_stack[left];
    //int right_it = lists_stack[right];

    int new_list_start = -1;
    int last_pushed = -1;
    //это для того, чтобы при вычитании обьектов на стенках отображалась правильная текстура, т е текстура самого внутреннего обьекта. но глубина такого запоминания ограничена
    #define MAX_SUB_DEPTH 10
    int left_rememb[MAX_SUB_DEPTH];
    while (left_it != -1 && right_it != -1)
    {
        if (intersections_stack[left_it].data.t < intersections_stack[right_it].data.t - 1e-6 * (1 - 2*int(in_a)))
        {
            if (in_b == 0)
            {
                pushBackToList(new_list_start, last_pushed, left_it);
                
            }
            left_rememb[in_a] = intersections_stack[left_it].object_index;
            in_a += 2*int(intersections_stack[left_it].is_in) - 1;
            left_it = intersections_stack[left_it].next_index;
        }
        else
        {
            if (in_a > 0)
            {
                pushBackToList(new_list_start, last_pushed, right_it);
                //при этом last_pushed == right_it
                intersections_stack[last_pushed].is_in = !intersections_stack[right_it].is_in;
                intersections_stack[last_pushed].data.n = -1 * intersections_stack[right_it].data.n;
                intersections_stack[last_pushed].object_index = left_rememb[min(in_a - 1, MAX_SUB_DEPTH)];
                in_b += 2*int(!intersections_stack[last_pushed].is_in) - 1;
            }
            else
                in_b += 2*int(intersections_stack[right_it].is_in) - 1;
            right_it = intersections_stack[right_it].next_index;
        }
    }
    while (left_it != -1)
    {
        pushBackToList(new_list_start, last_pushed, left_it);
        left_it = intersections_stack[left_it].next_index;
    }
    pushBackToList(new_list_start, last_pushed, -1);
    return new_list_start;
}
//иерархия - обьединение непересекающихся в пространстве обьектов, для которых можно не учитывать промежуточные точки.
//аутпут иерархии - всего две точки. Все остальные точки будут выброшены, и стек индекс ресетнут.
int combineOnHierarchy(int left_it, int right_it)
{
    if (left_it == -1)
    {
        if (right_it == -1)
            return -1;
        left_it = right_it;
        right_it = -1;
    }
    if (right_it == -1 || intersections_stack[left_it].data.t < intersections_stack[right_it].data.t)
    {
        if (intersections_stack[left_it].next_index != left_it + 1)
        {
            int left_list_ind = intersections_stack[left_it].next_index;
            while (intersections_stack[left_list_ind].next_index != -1)
            {
                left_list_ind = intersections_stack[left_list_ind].next_index;
            }
            intersections_stack[left_it].next_index = left_it + 1;
            intersections_stack[left_it + 1] = intersections_stack[left_list_ind];
        }
        else
            intersections_stack[left_it+1].next_index = -1;
        
    }
    else
    {
        int right_list_ind = intersections_stack[right_it].next_index;
        while (intersections_stack[right_list_ind].next_index != -1)
        {
            right_list_ind = intersections_stack[right_list_ind].next_index;
        }
        intersections_stack[left_it] = intersections_stack[right_it];
        intersections_stack[left_it].next_index = left_it + 1;
        intersections_stack[left_it + 1] = intersections_stack[right_list_ind];
    }
    stack_index = left_it + 2;
    return left_it;
}


int combineObjects(int current, int left_it, int right_it)
{
    switch(composed_objects[current].operation)
    {
    case OBJECTS_ADD:
        return uniteObjects( left_it, right_it);
        ;
    case OBJECTS_MULT:
        return intersectObjects( left_it, right_it);
        ;
    case OBJECTS_SUB:
        return subtractObjects( left_it, right_it);
        ;
    case OBJECTS_HIERARCHY:
        return combineOnHierarchy(left_it, right_it);

    }
}


FullIntersectionResult intersectWithRay(vec3 camera_pos, vec3 dir, int root, out bool has_intersection)
{
    int current = root + 0;
    int prev = root -1;

    int left_stack_list_index[MAX_TREE_DEPTH];
    left_stack_list_index[0] = -1;
    int stack_list_depth = 0;
    //has_intersection = true;
    int prev_node_list_index =  -1;

    while (current != root -1)
    {
        if (prev == ComposedObjectNode_parent(root, current))
        {
            int left = ComposedObjectNode_left(root, current);
            if (composed_objects[left].bb_index > -1)
            {
                if (!checkIfLineIntersectBox(bb_data[composed_objects[left].bb_index].hsize, camera_pos - bb_data[composed_objects[left].bb_index].position, dir))
                {
                    prev_node_list_index = -1;
                    prev = left;
                    continue;
                }
            }
            if (ComposedObjectNode_isPrimitive(composed_objects[left]))
            {
                prev_node_list_index = intersectWithPrimitiveAsNode(left, camera_pos, dir); 
                prev = left;
            }
            else
            {
                prev = current;
                current = left;
                continue;
            }
        }
        else if (prev == ComposedObjectNode_left(root, current))
        {
            left_stack_list_index[stack_list_depth] = prev_node_list_index;
            stack_list_depth++;
            
            int right = ComposedObjectNode_right(root, current);
            if (composed_objects[right].bb_index > -1)
            {
                if (!checkIfLineIntersectBox(bb_data[composed_objects[right].bb_index].hsize, camera_pos - bb_data[composed_objects[right].bb_index].position, dir))
                {
                    prev_node_list_index = -1;
                    prev = right;
                    continue;
                }
            }
            if (ComposedObjectNode_isPrimitive(composed_objects[right]))
            {
                prev_node_list_index = intersectWithPrimitiveAsNode(right, camera_pos, dir);
                prev = right;
            }
            else
            {
                prev = current;
                current = right;
                continue;
            }
        }
        else
        {
            int left = ComposedObjectNode_left(root, current);
            int right = prev;
            stack_list_depth--;
            
            prev_node_list_index = combineObjects(current, left_stack_list_index[stack_list_depth], prev_node_list_index);
            prev = current;
            current = ComposedObjectNode_parent(root, current);
        }
    }

    if (prev_node_list_index == -1)
    {
        has_intersection = false;
        FullIntersectionResult res = { {{0,0,0},0}, {0,0,0,0},0};
        return res;
    }
    has_intersection = true;

    
    vec3 normalized_ray_dir = normalize(dir);
    //NORMAL COLOR BLENDING
    /**/vec4 color = primitives[ComposedObjectNode_getPrimitiveIndex(composed_objects[intersections_stack[prev_node_list_index].object_index])].color;
    color.rgb *= -dot(normalized_ray_dir, intersections_stack[prev_node_list_index].data.n);
    color.a = 1;
    float passed_alph = 1 - color.a;
    int current_node = intersections_stack[prev_node_list_index].next_index;
    while (current_node != -1 && passed_alph > 0.01 )
    {
        int current_node_primitive = ComposedObjectNode_getPrimitiveIndex(composed_objects[intersections_stack[current_node].object_index]);
        color.rgb = mix(color.xyz, primitives[current_node_primitive].color.rgb * abs(dot(normalized_ray_dir, intersections_stack[current_node].data.n)), passed_alph);
        passed_alph *= (1 - primitives[current_node_primitive].color.a);
        current_node = intersections_stack[current_node].next_index;
    }
    
    color.a = 1 - passed_alph;

    //Meshkin’s Method
    /*vec4 color = primitives[ComposedObjectNode_getPrimitiveIndex(composed_objects[intersections_stack[lists_stack[0]].object_index])].color;
    color.rgb *= -dot(normalized_ray_dir, intersections_stack[lists_stack[0]].data.n);
    color.rgb *= color.a;
    float passed_alph = 1 - color.a;
    float alpha_sum = color.a;
    int current_node = intersections_stack[lists_stack[0]].next_index;
    while (current_node != -1 && passed_alph > 0.01)
    {
        int current_node_primitive = ComposedObjectNode_getPrimitiveIndex(composed_objects[intersections_stack[current_node].object_index]);
        vec3 other_c = primitives[current_node_primitive].color.rgb * abs(dot(normalized_ray_dir, intersections_stack[current_node].data.n));
        color.rgb += other_c * primitives[current_node_primitive].color.a;
        current_node = intersections_stack[current_node].next_index;
        passed_alph *= (1 - primitives[current_node_primitive].color.a);
    }
    color.a = 1;*/

    //Bavoil and Myers’ Method
    /*vec4 color = primitives[ComposedObjectNode_getPrimitiveIndex(composed_objects[intersections_stack[prev_node_list_index].object_index])].color;
    color.rgb *= -dot(normalized_ray_dir, intersections_stack[prev_node_list_index].data.n);
    int current_node = intersections_stack[prev_node_list_index].next_index;
    color.rgb *= color.a;
    int n = 1;
    float alpha_sum = color.a;
    float passed_alph = 1 - color.a;
    float prev_mult = color.a;
    while (current_node != -1 && passed_alph > 0.01)
    {
        int current_node_primitive = ComposedObjectNode_getPrimitiveIndex(composed_objects[intersections_stack[current_node].object_index]);
        vec3 other_c = primitives[current_node_primitive].color.rgb * abs(dot(normalized_ray_dir, intersections_stack[current_node].data.n));
        color.rgb += other_c * primitives[current_node_primitive].color.a;
        n += 1;
        alpha_sum += primitives[current_node_primitive].color.a;
        current_node = intersections_stack[current_node].next_index;
        passed_alph *= (1 - primitives[current_node_primitive].color.a);
    }
    color.rgb = color.rgb / max(alpha_sum, 0.0001) * (1. - pow(1. - 1.0/n * alpha_sum, n));
    color.a = 1;*/

    //A New Blended OIT Method
    /*vec4 color = primitives[ComposedObjectNode_getPrimitiveIndex(composed_objects[intersections_stack[lists_stack[0]].object_index])].color;
    color.rgb *= -dot(normalized_ray_dir, intersections_stack[lists_stack[0]].data.n);
    int current_node = intersections_stack[lists_stack[0]].next_index;
    color.rgb *= color.a;
    float alpha_sum = color.a;
    float passed_alph = 1 - color.a;
    float prev_mult = color.a;
    while (current_node != -1 && passed_alph > 0.01)
    {
        int current_node_primitive = ComposedObjectNode_getPrimitiveIndex(composed_objects[intersections_stack[current_node].object_index]);
        vec3 other_c = primitives[current_node_primitive].color.rgb * abs(dot(normalized_ray_dir, intersections_stack[current_node].data.n));
        alpha_sum += primitives[current_node_primitive].color.a;
        passed_alph *= (1 - primitives[current_node_primitive].color.a);
        color.rgb += other_c * primitives[current_node_primitive].color.a;
        current_node = intersections_stack[current_node].next_index;
    }
    color.rgb = color.rgb / max(alpha_sum, 0.00001) * (1 - passed_alph);
    color.a = 1;*/

    //Blended OIT with weights
    /*vec4 color = primitives[ComposedObjectNode_getPrimitiveIndex(composed_objects[intersections_stack[lists_stack[0]].object_index])].color;
    color.rgb *= -dot(normalized_ray_dir, intersections_stack[lists_stack[0]].data.n);
    int current_node = intersections_stack[lists_stack[0]].next_index;
    color.rgb *= color.a;
    float alpha_sum = color.a;
    float passed_alph = 1 - color.a;
    float prev_mult = color.a;
    float A = color.a;
    float Z = intersections_stack[lists_stack[0]].data.t;
    float W = A * max(0.01, min(3000, 10.0/(0.00001 + (Z/5)*(Z/5) +  pow((Z/200), 6)    )));
    color.rgb *= W;
    alpha_sum *= W;
    while (current_node != -1 && passed_alph > 0.01)
    {
        int current_node_primitive = ComposedObjectNode_getPrimitiveIndex(composed_objects[intersections_stack[current_node].object_index]);
        vec3 other_c = primitives[current_node_primitive].color.rgb * abs(dot(normalized_ray_dir, intersections_stack[current_node].data.n));
        A = primitives[current_node_primitive].color.a;
        Z = intersections_stack[current_node].data.t;
        W = A * max(0.01, min(3000, 10.0/(0.00001 + (Z/5)*(Z/5) +  pow((Z/200), 6)    )));
        alpha_sum += primitives[current_node_primitive].color.a * W;
        passed_alph *= (1 - primitives[current_node_primitive].color.a);
        color.rgb += other_c * primitives[current_node_primitive].color.a * W;
        current_node = intersections_stack[current_node].next_index;
    }
    color.rgb = color.rgb / max(alpha_sum, 0.00001) * (1 - passed_alph);
    color.a = 1;*/

    FullIntersectionResult res = {intersections_stack[prev_node_list_index].data, color, intersections_stack[prev_node_list_index].object_index};
    return res;


}
hitAttributeEXT FullIntersectionResult hit_attrib;

void main()
{
    if (blas_objects[gl_GeometryIndexEXT] < 0)
    {
        bool has_intersection = false;
        FullIntersectionResult res = intersectWithRay(gl_WorldRayOriginEXT, gl_WorldRayDirectionEXT, -blas_objects[gl_GeometryIndexEXT], has_intersection);
        if (has_intersection)
        {
            hit_attrib = res;
            reportIntersectionEXT(res.inter.t, 0);
        }
    }
    else
    {
        int res = intersectWithRay(primitives[blas_objects[gl_GeometryIndexEXT]],blas_objects[gl_GeometryIndexEXT], gl_WorldRayOriginEXT, gl_WorldRayDirectionEXT);
        if (res >= 0)
        {
            hit_attrib.inter = intersections_stack[res].data;
            hit_attrib.color = primitives[blas_objects[gl_GeometryIndexEXT]].color;
            hit_attrib.color.rgb *= -dot(normalize(gl_WorldRayDirectionEXT), hit_attrib.inter.n);
            hit_attrib.object_index = blas_objects[gl_GeometryIndexEXT];
            reportIntersectionEXT(hit_attrib.inter.t, 0);
        }
    }
}
