#version 460
#extension GL_EXT_ray_tracing : require

struct Payload
{
  vec3 color;
  float hitDistance;
};

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(rgba32f, binding = 1) uniform image2D img_output;
layout(binding = 2) uniform u_obj_obj {
    vec3 camera_pos;
    ivec2 screen_size;
    int primitives_count;
    int data_count;
    int normals_count;
    int composed_object_nodes_count;
    int STACK_SIZE;
    int batches_count;
} ubo;

layout(location = 0) rayPayloadEXT Payload prd;

const vec2 screen_size = vec2(1000, 1000);

layout(binding = 10) buffer intersections_amount_buffer_object
{
    uint intersections_amount[];
};
struct IntersectionListUnit
{
    int next_index;
    bool is_in;
    //возможно хорошая идея переместить этот инт в Intersection. Хотя мне не нравится паддинг тогда ну и там оно бесполезно пока
    //здесь индекс обьекта с чем пересекся луч в виде индекса в дереве composed_objects. Таким образом, индекс примитива, это composed_object[object_index].operation (или лучше ComposedObjectNode_getPrimitiveIndex(object_index) )
    int object_index;
    int intersections_amount;
};
//IntersectionListUnit intersections_stack[ubo.STACK_SIZE];
layout(binding = 9) buffer intersection_stack_buffer_object
{
    IntersectionListUnit intersections_stack[];
};

void main() {
    // Initialize the payload data
    prd.color = vec3(0.0);
    prd.hitDistance = 10000;
    
    float horizontal_step = 2.0/ubo.screen_size.x;
    float vertical_step = 2.0 /ubo.screen_size.y;
    
    vec3 rayOrigin = ubo.camera_pos;
    for (int i = 0; i < ubo.batches_count; ++i)
    {
        ivec2 pixel_coord = ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y + i * gl_LaunchSizeEXT.y);
        vec3 rayDirection = vec3(-1 + pixel_coord.x * horizontal_step, 1, -1 + pixel_coord.y * vertical_step);

        intersections_amount[gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x] = 0;

        intersections_stack[(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x) * ubo.STACK_SIZE].intersections_amount = 0;

        traceRayEXT(
            topLevelAS,
            gl_RayFlagsNoOpaqueEXT,
            0xFF, // Cull mask
            0,    // SBT record offset
            0,    // SBT record stride
            0,    // Miss index
            rayOrigin,
            0.001,
            rayDirection,
            10000.0, // A large distance to ensure the ray can travel far
            0
        );

        imageStore(img_output, ivec2(pixel_coord.x, pixel_coord.y), vec4(prd.color.r , prd.color.g, prd.color.b, 1));
    }
    
    return;
}