#version 430
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

uniform vec3 camera_pos;
uniform ivec2 screen_size;


struct Quat
{
//a.x - a0, a - a.yzw
//к сожалению придется так из за padding
	vec4 a;
};
struct Primitive
{
	uint type;
	uint data_index;
	//сколько элементов в data_array она занимает
	uint data_count;
	uint normals_index;
	vec4 position;
	Quat rotation;
	uint normals_count;
	//половина высоты для призмы и цилиндра, высота для пирамиды, радиус для сферы
	float sc1;
	//радиус для цилиндра
	float sc2;
};

uniform int primitives_count;
uniform int data_count;

layout(binding = 1) buffer primitives_array
{
	Primitive primitives[];
};
layout(binding = 2, std430) buffer data_array
{
	vec2 base_points[];
};
layout(binding = 3, packed) buffer normals_array
{
	vec3 normals[];
};

struct Intersection
{
	float t;
	vec3 n;
};

struct IRO
{
	int inters;
	Intersection first, second;
};


//они дублируются в glsl_structures.h, лучше не менять
const uint PRIZM = 0;
const uint PIRAMID = 1;
const uint SPHERE = 2;
const uint CYLINDR = 3;


//некоторая инкапсуляция для примитивов. sc1, sc2 - это еще ладно но обращение к буферам точно надо
uint Prizm_polygonStart(Primitive obj)
{
	return obj.data_index;
}

uint Prizm_polygonSize(Primitive obj)
{
	return obj.data_count;
}

uint Prizm_normalsStart(Primitive obj)
{
	return obj.normals_index;
}

uint Prizm_normalsSize(Primitive obj)
{
	return obj.normals_count;
}



Quat mult(in Quat a, in Quat b)
{
	return Quat(vec4(a.a.x * b.a.x - dot(a.a.yzw, b.a.yzw), a.a.x * b.a.yzw + b.a.x * a.a.yzw + cross(a.a.yzw, b.a.yzw)));
}

Quat inverseRot(in Quat q)
{
	return Quat(vec4(q.a.x, -1 * q.a.yzw));
}


mat4 rotation(in Quat q)
{
	float a0 = q.a.x;
	float a1 = q.a.y;
	float a2 = q.a.z;
	float a3 = q.a.w;

	return mat4(a1*a1 + a0*a0 - a2*a2 - a3*a3, 2*a2*a1 + 2*a0*a3, 2*a3*a1 - 2*a0*a2, 0, 2*a2*a1 - 2*a3*a0, a2*a2 + a0*a0 - a3*a3 - a1*a1, 2*a3*a2 + 2*a1*a0, 0, 2*a3*a1 + 2*a2*a0, 2*a3*a2 - 2*a1*a0, a3*a3 + a0*a0 - a2*a2 - a1*a1, 0, 0, 0, 0, 1);
}


void rotate(inout Quat q, float angle, vec3 n) {
	q = mult(q, Quat(vec4(cos(angle / 2), sin(angle / 2) * normalize(n))));
}




const IRO ZERO_IRO = IRO(0, Intersection(0, vec3(0,0,0)), Intersection(0, vec3(0,0,0)));



IRO intersectSphereWithLine(in Primitive sphere, in vec3 start, in vec3 dir)
{

	float rad = sphere.sc1;
	float A = dot(dir, dir);
	float B_half = dot(start, dir);
	float C = dot(start, start) - rad * rad;

	float D_4 = B_half * B_half - A * C;
	if (D_4 < 0)
	{
		return ZERO_IRO;
	}
	float D_sq = sqrt(D_4);
	float t1 = (-B_half - D_sq) / A;
	float t2 = (-B_half + D_sq) / A;

	IRO res = {2, {t1, (start + dir * t1)*(1.0/rad)}, {t2, (start + dir * t2)*(1.0/rad)}};
	return res;
}

bool equal(float a, float b)
{
	return abs(a - b) < 1e-5;
}
IRO intersectLineWithCircle(in vec2 p, in vec2 dir, float rad)
{
	float A = (dir.x * dir.x + dir.y * dir.y);
	float B_half = p.x * dir.x + p.y * dir.y;
	float C = p.x * p.x + p.y * p.y - rad * rad;
	float D = B_half * B_half - A * C;
	if (D < 0)
		return ZERO_IRO;
	float D_sq = sqrt(D);
	//не уверен что это нужно и полезно
	if (equal(D_sq, 0))
	{
		float t = -B_half / A;
		vec2 point = p + t * dir;
		IRO res = {1, {t, vec3(p.xy, 0)}, {t, vec3(p.xy, 0)}};
		return res;
	}
	float t1 = (-B_half + D_sq) / A;
	float t2 = (-B_half - D_sq) / A;
	vec2 p1 = (p + dir * t1) * (1.0/rad);
	vec2 p2 = (p + dir * t2) * (1.0/rad);
	IRO res = { 2, {t1, vec3(p1,0)}, {t2, vec3(p2, 0)} };
	return res;
}

void swap(inout Intersection a, inout Intersection b)
{
	Intersection c = a;
	a = b;
	b = c;
}

void swap(inout float a, inout float b)
{
	float c = a;
	a = b;
	b = c;
}

IRO intersectCylinderWithLine(in Primitive obj, in vec3 start, in vec3 dir)
{
	float rad = obj.sc2;
	float half_height = obj.sc1;
	if (equal(dir.x, 0.0) && equal(dir.y, 0.0))
	{
		bool in_res = dot(start, start) < rad * rad;
		if (in_res)
		{
			IRO res = {2, {(half_height - start.z) / dir.z, {0,0,1}}, {(-half_height - start.z) / dir.z,{0,0,-1}}};
			return res;
		}
		return ZERO_IRO;
	}
	IRO shade_intersect = intersectLineWithCircle(start.xy, dir.xy, rad);

	if (shade_intersect.inters == 0)
	{
		return shade_intersect;
	}

	Intersection t1 = shade_intersect.first;
	float point_z = start.z + dir.z * t1.t;
	if (shade_intersect.inters == 1)
	{
		if (point_z >= -half_height && point_z <= half_height)
		{
			return shade_intersect;
		}
		return ZERO_IRO;
	}
	Intersection t2 = shade_intersect.second;
	float point_z2 = start.z + dir.z * t2.t;
	if (!(point_z >= -half_height && point_z <= half_height) && (point_z2 >= -half_height && point_z2 <= half_height))
	{
		swap(t1, t2);
		swap(point_z, point_z2);
		swap(shade_intersect.first, shade_intersect.second);
	}
	if (point_z >= -half_height && point_z <= half_height)
	{
		if (point_z2 >= -half_height && point_z2 <= half_height)
			return shade_intersect;
		//z != 0 т к произошел подьем

		if (point_z2 > half_height)
		{
			float t_out = (half_height - start.z) / dir.z;
			IRO res = {2, t1, {t_out, {0,0,1}}};
			return res;
		}
		if (point_z2 < -half_height)
		{
			float t_out = (-half_height - start.z) / dir.z;
			IRO res = {2, t1, {t_out, {0, 0, -1}}};
			return res;

		}
	}
	//осталось возможна только ситуация когда линия проходит через оба основания либо вообще не проходит
	if (equal(dir.z, 0))
	{
		return ZERO_IRO;
	}
	float t_out = (half_height - start.z) / dir.z;
	vec2 up_point = (start + dir * t_out).xy;
	if (dot(up_point, up_point) < rad * rad)
	{
		IRO res = {2, {t_out, {0,0,1}}, {(-half_height - start.z) / dir.z, {0,0,-1}}};
		return res;
	}
	
	return IRO(0, Intersection(0, vec3(0,0,0)), Intersection(0, vec3(0,0,0)));
}

uint POINT_ON_BOUNDARY;
uint POINT_IN_POLYGON;
uint POINT_OUT_OF_POLYGON;

//специфичное сравнение для проверки на принадлежность многоугольнику
int compareDouble(double a, double b, double eps)
{
	if (abs(a - b) < eps)
		return 0;
	else if (a < b)
		return -1;
	else
		return 1;
}

int sideOfPointRelativeToLine(vec2 point, vec2 low, vec2 high)
{
	//considering low.y < high.y
	vec2 v1 = high - low;
	vec2 v2 = point - low;
	float z_orient = v1.x * v2.y - v1.y * v2.x;

	return compareDouble(0, z_orient, 1e-4);
}

uint isPointInsidePolygon(vec2 p, uint pol_start, uint pol_size)
{

	int current = 0;
	if (pol_size < 2)
		return POINT_OUT_OF_POLYGON;

	bool IsInside = false;
	int cur_y_comp_res = compareDouble(base_points[pol_start + current].y, p.y, 1e-4);
	int next = 1;
	do 
	{
		
		int next_y_comp_res = compareDouble(base_points[pol_start + next].y, p.y, 1e-4);
		switch (cur_y_comp_res) {
		case -1:
			switch (next_y_comp_res) {
			case -1:
				break;
			case 0:
				switch (compareDouble(p.x, base_points[pol_start + next].x, 1e-4)) {
				case -1: IsInside = !IsInside; break;
				case 0:   return POINT_ON_BOUNDARY;
				case 1:  break;
				}
				break;
			case 1:
				switch (sideOfPointRelativeToLine(p, base_points[pol_start + current], base_points[pol_start + next])) {
				case -1: IsInside = !IsInside; break;
				case  0: return POINT_ON_BOUNDARY;
				}
				break;
			}
			break;
		case 0:
			switch (next_y_comp_res) {
			case -1:
				switch (compareDouble(p.x, base_points[pol_start + current].x, 1e-4)) {
				case -1: IsInside = !IsInside; break;
				case 0:   return POINT_ON_BOUNDARY;
				case 1:  break;
				}
				break;
			case 0:
				switch (compareDouble(p.x, base_points[pol_start + current].x, 1e-4)) {
				case -1:
					if (compareDouble(p.x, base_points[pol_start + next].x, 1e-4) != -1)
						return POINT_ON_BOUNDARY;
					break;
				case 0: return POINT_ON_BOUNDARY;
				case 1:
					if (compareDouble(p.x, base_points[pol_start + next].x, 1e-4) != 1)
						return POINT_ON_BOUNDARY;
					break;
				}
				break;
			case 1:
				if (compareDouble(p.x, base_points[pol_start + current].x, 1e-4) == 0) {
					return POINT_ON_BOUNDARY;
				}
				break;
			}
			break;
		case 1:
			switch (next_y_comp_res) {
			case -1:
				switch (sideOfPointRelativeToLine(p, base_points[pol_start + next], base_points[pol_start + current])) {
				case -1: IsInside = !IsInside; break;
				case  0: return POINT_ON_BOUNDARY;
				}
				break;
			case 0:
				if (compareDouble(p.x, base_points[pol_start + next].x, 1e-4) == 0) {
					return POINT_ON_BOUNDARY;
				}
				break;
			case 1:
				break;
			}
			break;
		}

		current = next;
		cur_y_comp_res = next_y_comp_res;
		++next;
		if (next == pol_size)
			next = 0;
	} while (current != 0);

	return IsInside ? POINT_IN_POLYGON : POINT_OUT_OF_POLYGON;
}



float getParam(vec2 st, vec2 dir, vec2 p)
{
	if (equal(dir.x, 0))
	{
		return (p.y - st.y) / dir.y;
	}
	return (p.x - st.x) / dir.x;
}

struct BF_pair
{
	bool b;
	float f;
};

BF_pair rayIntersectsSegment(vec2 p, vec2 dir, vec2 a, vec2 b)
{
	float div = dir.x * (b.y - a.y) - dir.y * (b.x - a.x);
	float num = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);
	if (equal(div, 0))
	{
		if (equal(num, 0))
		{
			if (dot(b - p, a - p) < 0)
			{
				BF_pair res =  { true, 0 };
				return res;
			}
			else if (dot(dir, a - p) < 0)
			{
				BF_pair res =  { false, 0 };
				return res;
			}
			else if (dot(a - p, a - p) < dot(b - p, b - p))
			{
				BF_pair res =  { true, getParam(p, dir, a) };
				return res;
			}
			else
			{
				BF_pair res =  { true,getParam(p, dir, b) };
				return res;
			}

		}
		else
			{
				BF_pair res =  { false, 0 };
				return res;
			}
	}
	else
	{
		vec2 point = p + dir * (num / div);
		if (dot(b - point, a - point) <= 0)
		{
			BF_pair res = {true, num/div};
			return res;
		}
		BF_pair res =  { false, 0 };
		return res;
	}

}




IRO rayIntersectsPolygon(vec2 p, vec2 n, uint polygon_start, uint polygon_size, uint normals_start, uint normals_size)
{
	int c = 0;
	Intersection res[2];
	for (int i = 0; i < polygon_size; ++i)
	{
		BF_pair int_res = rayIntersectsSegment(p, n, base_points[polygon_start + i],base_points[polygon_start + (i < polygon_size - 1 ? i + 1 : 0)]);
		if (!int_res.b)
			continue;
		vec2 point = p + n * int_res.f;

		if (c == 1 && equal(int_res.f, res[0].t))
			continue;
		c++;
		res[c].t = int_res.f;
		res[c].n = normals[normals_start + i];
		if (c == 2)
			break;
	}
	//if (res[0].t < res[1].t)
	//	res[0].in = true;
	//else
	//	res[1].in = true;
	IRO irores = { c, res[0], res[1] };
	return irores;

}


//только выпуклые
IRO intersectPrizmWithLine(Primitive obj, in vec3 start, in vec3 dir)
{
	float EPSILON = 1e-6;
	float half_height = obj.sc1;
	if (equal(dir.x, 0) && equal(dir.y, 0))
	{
		uint in_res = isPointInsidePolygon(start.xy, Prizm_polygonStart(obj), Prizm_polygonSize(obj));
		if (in_res != POINT_OUT_OF_POLYGON)
		{
			float t_up = (half_height - start.z) / dir.z;
			float t_down = (-half_height - start.z) / dir.z;
			if (t_up < t_down)
			{
				IRO res = {2,  {t_up, {0,0,1}}, {t_down, {0,0,-1} }};
				return res;
			}
			else
			{
				IRO res = {2,  {t_down, {0,0,-1}} , {t_up, {0,0,1}} };
				return res;
			}
		}
		return ZERO_IRO;
	}
	IRO shade_intersect = rayIntersectsPolygon(start.xy, dir.xy, Prizm_polygonStart(obj), Prizm_polygonSize(obj), Prizm_normalsStart(obj), Prizm_normalsSize(obj));

	if (shade_intersect.inters == 0)
	{
		return ZERO_IRO;
	}

	Intersection t1 = shade_intersect.second;
	float point_z = start.z + dir.z * t1.t;
	if (shade_intersect.inters == 1)
	{
		//если токо одно пересечение то пока не рисуем
		return ZERO_IRO;
		if (point_z >= -half_height - EPSILON && point_z <= half_height + EPSILON)
		{
			//если все же вернусь сюда то надо не забыть проставить нормально in и out
			IRO res = { 1, t1, t1 };
			return res;
		}
		return ZERO_IRO;
	}
	Intersection t2 = shade_intersect.second;
	float point_z2 = start.z + dir.z * t2.t;
	if (!(point_z >= -half_height - EPSILON && point_z <= half_height + EPSILON) && (point_z2 >= -half_height - EPSILON && point_z2 <= half_height + EPSILON))
	{
		swap(t1, t2);
		swap(point_z, point_z2);
		swap(shade_intersect.first, shade_intersect.second);
	}
	if (point_z >= -half_height - EPSILON && point_z <= half_height + EPSILON)
	{

		if (point_z2 >= -half_height - EPSILON && point_z2 <= half_height + EPSILON)
		{
			if (t1.t < t2.t)
			{
				IRO res = {2, t1, t2 };
				return res;
			}
			else
			{
				IRO res = {2, t2, t1};
				return res;
			}
		}
		//z != 0 т к произошел подьем

		if (point_z2 > half_height + EPSILON)
		{
			float t_out = (half_height - start.z) / dir.z;
			if (t1.t < t_out)
			{
				IRO res = {2,  t1, {t_out, {0, 0, 1} } };
				return res;
			}
			else
			{
				IRO res = {2,  {t_out, {0, 0, 1} }, t1 };
				return res;
			}
			//невозможная ситуация, т к если он не выходит в стене то должен выходить наверху но мало ли
			IRO res = {2, t1, t1 };
			return res;
		}
		if (point_z2 < -half_height - EPSILON)
		{
			float t_out = (-half_height - start.z) / dir.z;
			if (t1.t < t_out)
			{
				IRO res = {2, t1, {t_out, {0, 0, -1} } };
				return res;
			}
			else
			{
				IRO res = {2, {t_out, {0, 0, -1} }, t1 };
				return res;
			}
			IRO res = {2,  t1, t1 };
			return res;
		}
	}
	//осталось возможна только ситуация когда линия проходит через оба основания, через верхнее/нижнее ребро, либо вообще не проходит
	if (equal(dir.z, 0))
	{
		return ZERO_IRO;
	}
	float t_out = (half_height - start.z) / dir.z;
	vec2 up_point = start.xy + dir.xy * t_out;
	if (isPointInsidePolygon(up_point, Prizm_polygonStart(obj), Prizm_polygonSize(obj)) != POINT_OUT_OF_POLYGON)
	{
		float t_bot = (-half_height - start.z) / dir.z;
		if (t_out < t_bot)
		{
			IRO res = {2, {t_out, {0,0,1}},  {t_bot, {0,0,-1}} };
			return res;
		}
		else
		{
			IRO res = {2, {t_bot, {0,0,-1}},  {t_out, {0,0,1}} };
			return res;
		}
	}

	return ZERO_IRO;
}






IRO intersectWithRay(in Primitive object, in vec3 ray_start, in vec3 direction)
{
	//Matrix<4> transposition(Vector<4>(1, 0, 0, -position.x()), Vector<4>(0, 1, 0, -position.y()), Vector<4>(0, 0, 1, -position.z()), Vector<4>(0, 0, 0, 1));
	mat4 transposition = mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -object.position.x, -object.position.y, -object.position.z, 1);

	mat4 rot = rotation(inverseRot(object.rotation));
	mat4 transformation = rot * transposition;

	vec3 start = (transformation * vec4(ray_start, 1)).xyz;
	vec3 dir = (rot * vec4(direction, 1)).xyz;

	IRO inter_res;

	switch(object.type)
	{
		case PRIZM:
			inter_res = intersectPrizmWithLine(object, start, dir);
		case PIRAMID:
			break;
		case CYLINDR:
			inter_res = intersectCylinderWithLine(object, start, dir);
			break;
		case SPHERE:
			inter_res = intersectSphereWithLine(object, start, dir);
			break;
	}
	if (inter_res.inters == 0)
		return inter_res;
	if (inter_res.first.t < 0 && inter_res.second.t < 0)
	{
		IRO res = {0, {0, {0,0,0}}, {0, {0,0,0}}};
		return res;
	}
	
	if (inter_res.second.t < inter_res.first.t && inter_res.second.t >= 0)
		swap(inter_res.first, inter_res.second);
	if (inter_res.second.t < 0)
	{
		inter_res.inters = 1;
	}
	//.first может быть < 0
	mat4 back_rotation = rotation(object.rotation);
	inter_res.first.n = (back_rotation * vec4(inter_res.first.n, 1)).xyz;
	inter_res.second.n = (back_rotation * vec4(inter_res.second.n, 1)).xyz;

	return inter_res;
}

float sq(float x)
{
	return x*x;
}

void main() {
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  float horizontal_step = 2.0/screen_size.x;
  float vertical_step = 2.0/screen_size.y;
  vec3 ray_dir = vec3(-1 + pixel_coords.x * horizontal_step, 1, -1 + pixel_coords.y * vertical_step);

  //imageStore(img_output, pixel_coords, vec4(float(primitives[0].sc1) / 1.05, 0, 0, 1));
  //return;
  IRO inter = intersectWithRay(primitives[0], camera_pos, ray_dir);
  if (inter.inters == 0)
	imageStore(img_output, pixel_coords, vec4(0,0,0,1));
  else
  {
	float r = (0.99 * sqrt((sq(dot(ray_dir, inter.first.n)) / dot(ray_dir, ray_dir))));
	imageStore(img_output, pixel_coords, vec4(r,r,r,1));
  }
  //
  // interesting stuff happens here later
  //
  
  // output to a specific pixel in the image
  //imageStore(img_output, pixel_coords, vec4(vec2(pixel_coords)/600, 1, 1));
  
}